---
phase: 01-foundation-core-generation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/ai/frd-schema.ts
  - src/lib/ai/prompt-composer.ts
  - src/lib/ai/generation-engine.ts
  - src/lib/ai/frd-renderer.ts
  - src/lib/ai/models.ts
  - src/lib/ai/templates/system.ts
  - src/app/api/projects/route.ts
  - src/app/api/projects/[projectId]/route.ts
  - src/app/api/generate/route.ts
autonomous: true

must_haves:
  truths:
    - "FRD is generated as a validated JSON object matching the Zod FRD schema (not free-text markdown)"
    - "FRD structured data converts to consistent, well-formatted Markdown deterministically"
    - "Prompts are composed entirely server-side -- no system prompt or composition logic exists in client-accessible code"
    - "Generation API rejects brain dumps exceeding 15,000 characters with a descriptive error"
    - "Generation API rejects brain dumps shorter than 50 characters with a descriptive error"
    - "Each generation saves an immutable version record in the Firestore subcollection"
    - "POST /api/projects creates a project and returns its ID"
    - "POST /api/generate returns structured FRD data and rendered markdown"
    - "Error responses never contain prompt content, brain dump text, or system prompt"
  artifacts:
    - path: "src/lib/ai/frd-schema.ts"
      provides: "Zod schema for structured FRD output with all sections"
      exports: ["FRDSchema", "FRD"]
    - path: "src/lib/ai/prompt-composer.ts"
      provides: "Server-side prompt assembly from user inputs"
      exports: ["composeGenerationPrompt"]
    - path: "src/lib/ai/generation-engine.ts"
      provides: "Gemini generateText call with Output.object() structured output"
      exports: ["generateFRD"]
    - path: "src/lib/ai/frd-renderer.ts"
      provides: "Deterministic conversion of FRD JSON to Markdown string"
      exports: ["renderFRDToMarkdown"]
    - path: "src/lib/ai/models.ts"
      provides: "Model configuration constants"
      exports: ["MODELS", "getModel"]
    - path: "src/lib/ai/templates/system.ts"
      provides: "System prompt for FRD generation"
      exports: ["SYSTEM_PROMPT"]
    - path: "src/app/api/projects/route.ts"
      provides: "POST handler for project creation"
      exports: ["POST"]
    - path: "src/app/api/generate/route.ts"
      provides: "POST handler for FRD generation"
      exports: ["POST"]
  key_links:
    - from: "src/lib/ai/generation-engine.ts"
      to: "ai SDK Output.object()"
      via: "generateText with output: Output.object({ schema: FRDSchema })"
      pattern: "Output\\.object.*FRDSchema"
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/ai/generation-engine.ts"
      via: "imports and calls generateFRD()"
      pattern: "import.*generateFRD.*from.*generation-engine"
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/db/versions.ts"
      via: "saves version after generation"
      pattern: "saveVersion"
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/ai/frd-renderer.ts"
      via: "renders structured FRD to markdown"
      pattern: "renderFRDToMarkdown"
    - from: "src/lib/ai/prompt-composer.ts"
      to: "src/lib/ai/templates/system.ts"
      via: "imports system prompt template"
      pattern: "import.*SYSTEM_PROMPT.*from.*system"
---

<objective>
Build the AI generation engine (FRD schema, prompt composer, generation engine, markdown renderer) and expose it through API route handlers for project creation and FRD generation.

Purpose: This is the core intelligence of the app -- the server-side pipeline that turns a brain dump into a structured, consistent FRD document. It enforces structured output via Gemini's responseSchema, composes prompts server-side (GEN-06), validates input sizes (GEN-05), and saves immutable versions (VER-01).
Output: Working API routes that accept user input, generate a structured FRD via Gemini, render it to markdown, save a version, and return the result.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-generation/01-RESEARCH.md
@.planning/phases/01-foundation-core-generation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AI generation engine -- FRD schema, prompt composer, system prompt, generation engine, markdown renderer, and model config</name>
  <files>
    src/lib/ai/frd-schema.ts
    src/lib/ai/prompt-composer.ts
    src/lib/ai/generation-engine.ts
    src/lib/ai/frd-renderer.ts
    src/lib/ai/models.ts
    src/lib/ai/templates/system.ts
  </files>
  <action>
    All files in `src/lib/ai/` must import `server-only` at the top to prevent client-side leakage (GEN-06).

    1. Create `src/lib/ai/models.ts` -- Model configuration:
    - Define a `MODELS` constant object with entries for `'gemini-2.5-flash'` and `'gemini-3-pro'`, each with `id` (the Gemini model ID string), `name` (display name), `description`, and `maxOutputTokens` (8192 for flash, 16384 for pro).
    - Export `getModel(modelId: string)` that returns the google() provider instance for the given model ID. Default to gemini-2.5-flash if invalid ID.
    - Use `import { google } from '@ai-sdk/google'`.

    2. Create `src/lib/ai/frd-schema.ts` -- Zod FRD schema for structured output:
    - Design the schema to map to the proven FRD template structure optimized for Claude Code consumption.
    - Use ONLY simple Zod types: `z.string()`, `z.number()`, `z.boolean()`, `z.array()`, `z.object()`, `z.enum()`. NO `z.union()`, `z.record()`, transforms, or refinements (these break Gemini structured output).
    - Add `.describe()` to EVERY field -- these map to JSON Schema descriptions that help Gemini understand what to generate.
    - Schema structure:
      ```
      FRDSchema = z.object({
        projectName: z.string(),
        coreValue: z.string(),  // One-line value proposition
        overview: z.string(),   // 2-3 paragraph project overview
        personas: z.array(z.object({
          name: z.string(),
          description: z.string(),
          goals: z.array(z.string()),
        })),
        requirements: z.array(z.object({
          id: z.string(),           // e.g., "REQ-01"
          category: z.string(),     // e.g., "User Management"
          description: z.string(),
          priority: z.enum(['must-have', 'should-have', 'nice-to-have']),
          acceptanceCriteria: z.array(z.string()),
        })),
        constraints: z.array(z.object({
          category: z.string(),
          description: z.string(),
        })),
        outOfScope: z.array(z.string()),
        assumptions: z.array(z.string()),
        openQuestions: z.array(z.string()),
      })
      ```
    - Export `FRDSchema` and the inferred type `FRD = z.infer<typeof FRDSchema>`.

    3. Create `src/lib/ai/templates/system.ts` -- System prompt:
    - Export `SYSTEM_PROMPT` as a string constant.
    - The system prompt must instruct Gemini to:
      - Act as a senior product analyst generating a Functional Requirements Document
      - Generate structured data matching the provided schema exactly
      - Focus on completeness: identify implicit requirements from the brain dump
      - Assign requirement IDs sequentially (REQ-01, REQ-02, ...)
      - Categorize requirements into logical groups
      - Set priorities based on user's emphasis and logical dependencies
      - Generate 2-4 personas based on the described use case
      - Identify constraints from both explicit mentions and reasonable inferences
      - List items explicitly out of scope based on the project description
      - Surface assumptions that need validation
      - Generate open questions about ambiguities in the input
      - Optimize the output for consumption by Claude Code (clear, unambiguous, actionable)
      - Do NOT add sections not defined in the schema
      - Do NOT include implementation details -- this is a requirements document, not a technical design

    4. Create `src/lib/ai/prompt-composer.ts` -- Server-side prompt assembly:
    - Import `SYSTEM_PROMPT` from templates/system
    - Export `composeGenerationPrompt(input: GenerationInput)` that returns `{ system: string, prompt: string }`
    - The `system` is `SYSTEM_PROMPT` (static)
    - The `prompt` is assembled from user inputs: "Generate a Functional Requirements Document for the following project.\n\nProject Name: {projectName}\n\nProject Description (Brain Dump):\n{brainDump}"
    - NEVER include the system prompt in the user-facing prompt
    - NEVER log or expose the composed prompt in any return value

    5. Create `src/lib/ai/generation-engine.ts` -- Core generation:
    - Import `generateText`, `Output` from `'ai'`
    - Import `composeGenerationPrompt` and `FRDSchema`
    - Import `getModel` from models
    - Export `generateFRD(input: GenerationInput)` async function:
      - Calls `composeGenerationPrompt(input)` to get system + prompt
      - Calls `generateText({ model: getModel('gemini-2.5-flash'), output: Output.object({ schema: FRDSchema }), system, prompt, maxTokens: 8192, temperature: 0.1 })`
      - If `result.output` is null/undefined, throw `new Error('No structured output generated')`
      - Return `{ frd: result.output, usage: { promptTokens, completionTokens, totalTokens } }`
    - The function MUST set `maxTokens: 8192` to prevent unbounded generation
    - Temperature 0.1 for consistency across generations

    6. Create `src/lib/ai/frd-renderer.ts` -- Deterministic markdown rendering:
    - Import `FRD` type from frd-schema
    - Export `renderFRDToMarkdown(frd: FRD): string` that converts the structured FRD JSON to a well-formatted Markdown string
    - Use the rendering pattern from the research document: heading hierarchy, bullet lists for personas/goals, requirement tables or sections with acceptance criteria as checkboxes, constraints as a list, out of scope as a list, open questions as a numbered list
    - This function is pure (no side effects) and deterministic (same input always produces same output)
    - The rendered markdown should be optimized for Claude Code consumption: clear headings, checkbox-style acceptance criteria, unambiguous language

    7. Verify: `npm run build` succeeds. `npm run lint` passes. Grep all ai/ files for `server-only` import.
  </action>
  <verify>
    Run `npm run build && npm run lint:check` -- both must exit 0. Run `grep -r "server-only" src/lib/ai/` -- every .ts file must include it. Run `grep -r "z\.union\|z\.record\|\.transform\|\.refine" src/lib/ai/frd-schema.ts` -- must return no matches (unsupported Zod features for Gemini).
  </verify>
  <done>
    AI generation engine exists with: FRD Zod schema (simple types only, all fields described), system prompt template, server-side prompt composer, generateText + Output.object() engine with maxTokens cap, and deterministic markdown renderer. All files import server-only. No unsupported Zod features used.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API route handlers for project creation and FRD generation</name>
  <files>
    src/app/api/projects/route.ts
    src/app/api/projects/[projectId]/route.ts
    src/app/api/generate/route.ts
  </files>
  <action>
    1. Create `src/app/api/projects/route.ts` -- Project creation endpoint:
    - Export `POST` handler
    - Parse request body with `CreateProjectSchema.parse(body)` (from validation/project.ts)
    - Call `createProject({ name: input.name, mode: input.mode })` (from db/projects.ts)
    - Return `NextResponse.json({ projectId: result.id }, { status: 201 })`
    - On Zod validation error: return 400 with `{ error: 'Invalid input', details: error.issues }`
    - On unexpected error: return 500 with `{ error: 'Failed to create project' }` -- do NOT expose internal error details

    2. Create `src/app/api/projects/[projectId]/route.ts` -- Get project endpoint:
    - Export `GET` handler
    - Extract `projectId` from route params
    - Call `getProject(projectId)` to get the project document
    - If project is null, return 404 with `{ error: 'Project not found' }`
    - Call `getLatestVersion(projectId)` to get the latest version (may be null if no generation yet)
    - Return `NextResponse.json({ project, latestVersion })`

    3. Create `src/app/api/generate/route.ts` -- FRD generation endpoint:
    - Export `POST` handler
    - Parse request body with `GenerationRequestSchema.parse(body)` (from validation/generation.ts)
    - The Zod schema already enforces brainDump min 50 / max 15,000 chars (GEN-05), so validation errors provide the user feedback
    - Call `generateFRD({ projectId: input.projectId, projectName: input.projectName, brainDump: input.brainDump, mode: 'fast' })`
    - Call `renderFRDToMarkdown(frd)` to get the markdown string
    - Determine `versionNumber`: query existing version count or use project's `versionCount + 1`
    - Call `saveVersion(input.projectId, { content: markdown, structuredData: frd, mode: 'fast', model: 'gemini-2.5-flash', versionNumber, tokensUsed: usage.totalTokens, metadata: { promptTokens: usage.promptTokens, completionTokens: usage.completionTokens, generationTimeMs } })` (VER-01)
    - Call `updateProject(input.projectId, { latestVersionId: version.id, versionCount: versionNumber })`
    - Return `NextResponse.json({ versionId: version.id, markdown, structuredData: frd })`
    - Track `generationTimeMs` by recording `Date.now()` before and after the `generateFRD` call
    - Error handling (CRITICAL -- GEN-06 compliance):
      - On Zod validation error: return 400 with `{ error: 'Invalid input', details: error.issues }` -- details are safe (they describe validation rules, not user content)
      - On generation failure: `console.error('Generation failed:', { error: error.message })` -- NEVER log the brain dump, prompt, or FRD content. Return 500 with `{ error: 'FRD generation failed. Please try again.' }`
      - On Firestore save failure: return 500 with `{ error: 'Failed to save generation results' }`

    4. Verify: `npm run build` succeeds. `npm run lint` passes.
  </action>
  <verify>
    Run `npm run build && npm run lint:check` -- both must exit 0. Run `grep -rn "brainDump\|brain_dump\|prompt" src/app/api/generate/route.ts` and verify that brainDump/prompt only appear in: (a) parsing the request body, (b) passing to generateFRD(), and (c) NEVER in console.log/error output or error response bodies.
  </verify>
  <done>
    Three API routes exist and type-check: POST /api/projects (creates project, returns ID), GET /api/projects/[projectId] (returns project + latest version), POST /api/generate (validates input size, generates structured FRD via Gemini, renders to markdown, saves immutable version, returns result). Error responses never contain prompt or brain dump content.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` exits 0
2. `npm run lint:check` exits 0
3. All `src/lib/ai/*.ts` files contain `import 'server-only'`
4. FRD schema uses only simple Zod types (no union, record, transform, refine)
5. Generation route saves version to Firestore subcollection on every successful generation
6. Error responses in `/api/generate` route contain NO user content (brain dump, prompts)
7. `maxTokens: 8192` is set in the generateText call
8. Temperature is 0.1 in the generateText call
</verification>

<success_criteria>
- AI generation engine compiles and is ready to produce structured FRDs via Gemini
- API routes handle project creation, project retrieval, and FRD generation
- Structured output is enforced via Output.object() with the FRD Zod schema
- Input size limits (50-15000 chars) are enforced via Zod validation
- Every generation creates an immutable version in Firestore subcollection
- All server-side AI code imports server-only (not accessible to client)
- Error responses are sanitized -- no prompt data leakage
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-generation/01-02-SUMMARY.md`
</output>

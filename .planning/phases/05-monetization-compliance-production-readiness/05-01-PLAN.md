---
phase: 05-monetization-compliance-production-readiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/generate/route.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/lib/db/retention.ts
  - src/lib/db/credits.ts
autonomous: true

must_haves:
  truths:
    - "Generation is blocked server-side when credits are insufficient (returns 402 with balance and required amount)"
    - "Initial generation costs 50 credits and iteration costs 25 credits, deducted atomically via Firestore transaction"
    - "Credit charge is recorded with metadata including projectId, model, reason, and timestamp"
    - "If generation fails after credits are charged, credits are automatically refunded"
    - "Duplicate Stripe webhook deliveries do not result in double credit additions"
    - "Data retention cleanup handles projects with 500+ versions without Firestore batch limit errors"
    - "Credit transaction cleanup handles 500+ expired transactions without batch limit errors"
    - "Generation is blocked server-side when user has not accepted consent terms"
  artifacts:
    - path: "src/app/api/generate/route.ts"
      provides: "Credit charging, refund on failure, consent check, credit tracking"
      contains: "chargeCredits"
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Idempotent webhook processing"
      contains: "credit_transactions"
    - path: "src/lib/db/retention.ts"
      provides: "Chunked batch deletes for 500-doc Firestore limit"
      contains: "BATCH_LIMIT"
    - path: "src/lib/db/credits.ts"
      provides: "Credit refund support via addCredits with type refund"
      contains: "refund"
  key_links:
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/db/credits.ts"
      via: "chargeCredits() and addCredits() calls"
      pattern: "chargeCredits|addCredits"
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/db/consent.ts"
      via: "hasUserConsented() check before generation"
      pattern: "hasUserConsented"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/db/credits.ts"
      via: "addCredits() with idempotency guard"
      pattern: "credit_transactions.*stripeSessionId"
---

<objective>
Activate server-side credit charging in the generate route, harden the Stripe webhook with idempotency, fix Firestore batch delete limits in data retention, and add consent enforcement and credit refund on generation failure.

Purpose: This is the server-side backbone for all Phase 5 requirements. Credits must be charged atomically, refunded on failure, and tracked with metadata. The webhook must be safe against duplicate deliveries. Retention cleanup must handle large datasets. Consent must be enforced before generation.

Output: Four hardened server-side files with credit charging active, webhook idempotency, batch-safe retention, and consent enforcement.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/api/generate/route.ts
@src/app/api/webhooks/stripe/route.ts
@src/lib/db/retention.ts
@src/lib/db/credits.ts
@src/lib/db/consent.ts
@src/lib/stripe/config.ts
@src/lib/analytics.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Activate credit charging, consent enforcement, and refund on failure in generate route</name>
  <files>src/app/api/generate/route.ts</files>
  <action>
In `src/app/api/generate/route.ts`, make these changes:

1. **Add consent import** at the top: `import { hasUserConsented } from "@/lib/db/consent";`

2. **Add consent check** right after the rate limit check (after line 31), before parsing the request body:
   ```typescript
   // DATA-03: Require consent before generation
   const consented = await hasUserConsented(auth.userId);
   if (!consented) {
     return NextResponse.json(
       { error: "You must accept the terms of use before generating FRDs." },
       { status: 403 },
     );
   }
   ```

3. **Uncomment credit charging block** (lines 46-58): Remove the `// TODO: Phase 5` comment and uncomment the entire block. The block charges `CREDIT_COSTS.initial` (50) or `CREDIT_COSTS.iteration` (25) depending on `isIteration`, and returns 402 on insufficient credits.

4. **Add a `let creditCharged = false;` flag** right after the credit charging block (after the `chargeResult` check). Set it to `true` after the charge succeeds:
   ```typescript
   let creditCharged = false;
   // (place after the chargeResult success check)
   creditCharged = true;
   ```
   This flag is needed for the refund mechanism.

5. **Uncomment credit tracking block** (lines 148-159): Remove the `// TODO: Phase 5` comment and uncomment the `trackEvent` call for `credits_charged`.

6. **Add refund on failure**: In the `catch` block (around line 178), before the error logging, add:
   ```typescript
   // Refund credits if they were charged but generation failed
   if (creditCharged) {
     try {
       await addCredits(auth.userId, creditCost, {
         projectId: input.projectId,
         model: modelId,
         reason: "generation_failed_refund",
       });
       trackEvent(
         auth.userId,
         {
           event: "credits_purchased", // Reuse purchase event type for refund tracking
           amount: creditCost,
           packageLabel: "refund:generation_failed",
         },
         logger.correlationId,
       );
     } catch (refundError) {
       logger.error("Credit refund failed", {
         userId: auth.userId,
         action: "credit_refund_failed",
         metadata: { error: refundError instanceof Error ? refundError.message : "Unknown" },
       });
     }
   }
   ```
   Note: The `creditCost` and `input` variables must be declared in a scope accessible to the catch block. Currently `creditCost` is inside the try block — move its declaration (and `isIteration`) to before the try block, or restructure so the catch block can access them. The simplest approach: declare `let creditCost = 0;` and `let creditCharged = false;` before the try block, and assign `creditCost` inside the try after determining `isIteration`.

7. **Also add a generation_failed analytics event** in the catch block (after the refund logic, before the error response):
   ```typescript
   trackEvent(
     auth.userId,
     {
       event: "frd_generation_failed",
       projectId: input.projectId ?? "unknown",
       model: modelId ?? "unknown",
       errorType: error instanceof Error ? error.name : "Unknown",
     },
     logger.correlationId,
   );
   ```
   Note: `input` and `modelId` may not be available in all catch paths (e.g., if parsing failed). Guard with `?? "unknown"` or only emit this event when `input` is defined.

**Important scope consideration:** Variables `creditCost`, `creditCharged`, `input`, and `modelId` need to be accessible in the catch block for refund and failure tracking. The cleanest approach is:
- Declare `let creditCost = 0;`, `let creditCharged = false;` outside the try block.
- Keep `input` and `modelId` inside try (they depend on parsed body). The catch block should check `typeof creditCost !== 'undefined'` or simply guard the refund with `creditCharged` which is only true after both parsing and charging succeed.
  </action>
  <verify>
Run `npm run build` — no TypeScript errors. Run `npm run lint` — no Biome errors. Manually verify the generate route has: consent check (403), credit charge (402 on insufficient), credit tracking event, and refund in catch block.
  </verify>
  <done>
The generate route charges 50 credits for initial generation and 25 for iteration, returns 402 when insufficient, returns 403 when consent not given, tracks credit_charged event after success, and refunds credits on generation failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add idempotency to Stripe webhook and harden retention batch deletes</name>
  <files>src/app/api/webhooks/stripe/route.ts, src/lib/db/retention.ts</files>
  <action>
**Stripe webhook idempotency (`src/app/api/webhooks/stripe/route.ts`):**

Inside the `if (event.type === "checkout.session.completed")` block, right after extracting `session`, `userId`, `credits`, and `packageLabel`, add an idempotency check BEFORE the `addCredits` call:

```typescript
// Check for duplicate webhook delivery (idempotency)
const db = (await import("@/lib/db/admin")).getDb();
const existingTx = await db
  .collection("credit_transactions")
  .where("metadata.stripeSessionId", "==", session.id)
  .limit(1)
  .get();

if (!existingTx.empty) {
  logger.info("Duplicate Stripe webhook, skipping credit addition", {
    metadata: { sessionId: session.id, userId },
  });
  return NextResponse.json({ received: true });
}
```

Note: Import `getDb` at the top of the file instead of dynamic import. Add `import { getDb } from "@/lib/db/admin";` at top. Since this file is a server-side route handler (not a client component), this import is safe. However, the file does NOT currently have `import "server-only"` — and that's correct because route handlers are inherently server-only in Next.js App Router. The `getDb` import from `@/lib/db/admin` will work because admin.ts uses `server-only` which is fine for route handlers.

**Retention batch chunking (`src/lib/db/retention.ts`):**

Replace the current `deleteExpiredData()` function with a version that chunks batch deletes to stay within Firestore's 500-document limit:

1. Add a constant: `const BATCH_LIMIT = 499;` (499 to leave room for the project doc in the final batch).

2. Replace the single-batch version deletion loop with chunked batches:
   ```typescript
   // Delete versions in chunks to respect Firestore 500-doc batch limit
   const versions = await db.collection("projects").doc(projectId).collection("versions").get();

   if (versions.size === 0) {
     // No versions — just delete the project doc
     await db.batch().delete(projectDoc.ref).commit();
   } else {
     for (let i = 0; i < versions.docs.length; i += BATCH_LIMIT) {
       const chunk = versions.docs.slice(i, i + BATCH_LIMIT);
       const batch = db.batch();
       for (const doc of chunk) {
         batch.delete(doc.ref);
       }
       // Include project doc in last batch
       if (i + BATCH_LIMIT >= versions.docs.length) {
         batch.delete(projectDoc.ref);
       }
       await batch.commit();
     }
   }
   ```

3. Also chunk the credit_transactions cleanup at the bottom of the function:
   ```typescript
   if (expiredTransactions.size > 0) {
     for (let i = 0; i < expiredTransactions.docs.length; i += BATCH_LIMIT) {
       const chunk = expiredTransactions.docs.slice(i, i + BATCH_LIMIT);
       const txBatch = db.batch();
       for (const doc of chunk) {
         txBatch.delete(doc.ref);
       }
       await txBatch.commit();
     }
   }
   ```
   Note: For credit_transactions, use `BATCH_LIMIT` of 500 (not 499) since there's no additional document to include. Actually, to keep it simple and consistent, use 499 for all batches — one fewer operation per batch is negligible.
  </action>
  <verify>
Run `npm run build` — no TypeScript errors. Run `npm run lint` — no Biome errors. Verify: webhook route has idempotency check querying `credit_transactions` by `stripeSessionId`. Verify: retention.ts uses chunked batches with `BATCH_LIMIT` constant for both versions and credit_transactions.
  </verify>
  <done>
Stripe webhook returns early on duplicate session IDs without adding credits twice. Retention cleanup handles projects with any number of versions and credit_transactions by chunking batch deletes to stay within Firestore's 500-document limit.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. `npm run lint` passes with no Biome errors
3. `grep -r "TODO.*Phase 5" src/` returns zero matches (all Phase 5 TODOs resolved)
4. `src/app/api/generate/route.ts` contains `chargeCredits`, `hasUserConsented`, `addCredits` (refund), and `credits_charged` tracking
5. `src/app/api/webhooks/stripe/route.ts` contains `credit_transactions` query for idempotency
6. `src/lib/db/retention.ts` contains `BATCH_LIMIT` constant and chunked loops
</verification>

<success_criteria>
- Server-side credit charging is active (50 initial, 25 iteration)
- 402 returned on insufficient credits with balance/required info
- 403 returned when user hasn't consented
- Credits refunded on generation failure
- Duplicate webhook events are safely ignored
- Retention cleanup works for any dataset size
- All Phase 5 TODO comments are resolved
</success_criteria>

<output>
After completion, create `.planning/phases/05-monetization-compliance-production-readiness/05-01-SUMMARY.md`
</output>

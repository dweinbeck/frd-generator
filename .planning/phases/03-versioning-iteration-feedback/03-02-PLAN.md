---
phase: 03-versioning-iteration-feedback
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/db/__tests__/versions.test.ts
  - src/lib/validation/__tests__/generation.test.ts
  - src/app/api/projects/[projectId]/versions/__tests__/route.test.ts
autonomous: true

must_haves:
  truths:
    - "Timestamp serialization from Firestore Timestamp to ISO string is tested"
    - "Rating validation schema rejects invalid values (0, 5.5, 6, negative, non-step-of-0.5)"
    - "Version list API returns sanitized data with ISO string timestamps and no composedPrompt"
  artifacts:
    - path: "src/lib/validation/__tests__/generation.test.ts"
      provides: "RatingSchema validation tests"
      contains: "RatingSchema"
    - path: "src/app/api/projects/[projectId]/versions/__tests__/route.test.ts"
      provides: "Version list API response shape tests"
      contains: "createdAt"
  key_links:
    - from: "src/lib/validation/__tests__/generation.test.ts"
      to: "src/lib/validation/generation.ts"
      via: "imports and tests RatingSchema and GenerationRequestSchema"
      pattern: "import.*from.*validation/generation"
    - from: "src/app/api/projects/[projectId]/versions/__tests__/route.test.ts"
      to: "src/app/api/projects/[projectId]/versions/route.ts"
      via: "tests GET handler response shape"
      pattern: "import.*GET|import.*route"
---

<objective>
Add tests for the core Phase 3 logic: validation schemas (rating, generation request), timestamp serialization, and version list API response shape.

Purpose: Ensure the critical data flows -- rating validation, timestamp conversion, composedPrompt stripping -- are tested so regressions are caught automatically.

Output: Passing test suite covering validation schemas and API response contracts.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-versioning-iteration-feedback/03-01-SUMMARY.md
@src/lib/validation/generation.ts
@src/app/api/projects/[projectId]/versions/route.ts
@src/lib/db/versions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD validation schema tests (RatingSchema and GenerationRequestSchema iteration mode)</name>
  <files>
    src/lib/validation/__tests__/generation.test.ts
  </files>
  <action>
    **RED phase -- write failing tests first:**

    Create `src/lib/validation/__tests__/generation.test.ts` with these test cases:

    **RatingSchema tests:**
    - Valid: 0.5 (minimum), 2.5, 5.0 (maximum), 1.0, 3.5
    - Invalid: 0 (below minimum), 5.5 (above maximum), -1 (negative), 0.3 (not step of 0.5), 0.7 (not step of 0.5), "abc" (not a number), null, undefined

    **GenerationRequestSchema iteration mode tests:**
    - Valid iteration request: `{ projectId: "abc", projectName: "Test", brainDump: "", mode: "fast", parentVersionId: "v1", iterationFeedback: "add more detail", modelId: "gemini-2.5-flash" }` -- should parse successfully
    - Invalid: iteration with empty iterationFeedback (should fail .refine or validation)
    - Invalid: parentVersionId without iterationFeedback (should fail)

    Import schemas from `@/lib/validation/generation` (or use relative path `../generation` depending on Vitest alias config -- check `vitest.config.ts` or `vite.config.ts` for path aliases).

    Use Vitest `describe`/`it`/`expect` pattern. Import from `vitest`.

    Run tests: `npm test` -- they should FAIL (RED) if any schema behavior doesn't match expectations, or PASS if schemas already work correctly. In TDD, if tests pass immediately, that's fine -- the schemas already exist and work. The point is having the test coverage.

    **GREEN phase:** If any test fails, fix the test expectations to match actual schema behavior (the schemas are pre-existing and correct), OR fix the schema if the test reveals a genuine bug.

    **REFACTOR phase:** Clean up test organization if needed.
  </action>
  <verify>
    Run `npm test -- src/lib/validation/__tests__/generation.test.ts` -- all tests pass. Run `npm run lint` -- clean.
  </verify>
  <done>
    RatingSchema validation is tested for all boundary cases. GenerationRequestSchema iteration mode is tested for valid and invalid inputs. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test version list API response shape (timestamp serialization and composedPrompt stripping)</name>
  <files>
    src/app/api/projects/[projectId]/versions/__tests__/route.test.ts
  </files>
  <action>
    **RED phase -- write failing tests first:**

    Create `src/app/api/projects/[projectId]/versions/__tests__/route.test.ts` with these test cases:

    This is a unit test of the API handler's response transformation logic. Since the route handler depends on Firestore, mock the DB layer.

    **Mock setup:**
    - Mock `@/lib/auth/require-auth` to return `{ userId: "test-user" }`
    - Mock `@/lib/db/projects` `getProjectForUser` to return a project object
    - Mock `@/lib/db/versions` `getAllVersions` to return test data with Firestore-like timestamp objects

    **Test: Timestamps are serialized to ISO strings:**
    - Mock `getAllVersions` to return versions where `createdAt` is an object with a `toDate()` method returning a specific Date
    - Call the GET handler
    - Assert that `response.versions[0].createdAt` is an ISO date string (matches ISO 8601 format)

    **Test: composedPrompt is stripped from version list:**
    - Mock `getAllVersions` to return versions that include `composedPrompt: "some prompt"`
    - Call the GET handler
    - Assert that response versions do NOT have a `composedPrompt` property

    **Test: Returns 404 for non-existent project:**
    - Mock `getProjectForUser` to return null
    - Call the GET handler
    - Assert 404 status

    Use Vitest's `vi.mock()` for mocking. Create the Request object with `new Request('http://localhost/api/projects/test-project/versions')`. Pass params as `{ params: Promise.resolve({ projectId: 'test-project' }) }`.

    **GREEN phase:** If tests fail due to mocking issues or import path problems, fix them. The route handler code from Plan 01 should already serialize timestamps correctly.

    **REFACTOR phase:** Extract mock factories if tests share setup.
  </action>
  <verify>
    Run `npm test -- src/app/api/projects/[projectId]/versions/__tests__/route.test.ts` -- all tests pass. Run `npm test` -- all project tests pass. Run `npm run lint` -- clean.
  </verify>
  <done>
    Version list API response shape is tested: timestamps are ISO strings, composedPrompt is stripped, 404 returned for unknown projects. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. All validation schema tests pass: `npm test -- src/lib/validation/__tests__/generation.test.ts`
2. All API route tests pass: `npm test -- src/app/api/projects/[projectId]/versions/__tests__/route.test.ts`
3. Full test suite passes: `npm test`
4. Lint passes: `npm run lint`
5. Build passes: `npm run build`
</verification>

<success_criteria>
- All tests pass with `npm test`
- RatingSchema boundary cases covered (min, max, invalid step, out of range)
- GenerationRequestSchema iteration mode covered (valid request, missing feedback)
- Version list API response tested for timestamp serialization and composedPrompt stripping
- `npm run build` and `npm run lint` pass with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-versioning-iteration-feedback/03-02-SUMMARY.md`
</output>
